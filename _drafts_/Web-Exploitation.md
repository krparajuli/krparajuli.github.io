
### Table of Contents
- [Exploitation](#exploitation)
  - [1. HTTP Host Header Attack](#1-http-host-header-attack)
    - [Vector For](#vector-for)
    - [Arises From](#arises-from)
    - [Mitigations](#mitigations)
  - [2. Cross-Site Scripting (XSS)](#2-cross-site-scripting-xss)
  - [3. SQL Injection (SQLi)](#3-sql-injection-sqli)
  - [4. HTTP Request Smuggling (CL.TE and TE.CL)](#4-http-request-smuggling-clte-and-tecl)
    - [TE.CL (Tranfer-Encoding; Content-Length)](#tecl-tranfer-encoding-content-length)
    - [CL.TE (Content-Length; Transfer-Encoding)](#clte-content-length-transfer-encoding)
    - [TE.TE (Obfuscating the TE Header)](#tete-obfuscating-the-te-header)
    - [Mitigations](#mitigations-1)
  - [References](#references)


# Exploitation
## 1. HTTP Host Header Attack
Due to the ever-growing trend for cloud-based solutions and outsourcing much of the related architecture, it is common for multiple websites and applications to be accessible at the same IP address. They are used for `Virtual Hosting` like in IaaS or PaaS and `Routing Traffic via Intermediary` like Load Balancer or Reverse Proxy. Thus, HTTP `Host` header has become ubiquitous and exploitable.[[1]](https://portswigger.net/web-security/host-header)


HTTP Host header attacks exploit vulnerable websites that handle the value of the Host header in an unsafe way. If the server implicitly trusts the Host header, and fails to validate or escape it properly, an attacker may be able to use this input to inject harmful payloads that manipulate server-side behavior. Attacks that involve injecting a payload directly into the Host header are often known as "Host header injection" attacks.

    ```http
    GET /web-security HTTP/1.1
    Host: portswigger.net
    ```

### Vector For
1. Web Cache Poisoning
2. Business logic flaws
3. Routing based SSRF
4. Classic Server-Side vulnerabilities like SQL injection

### Arises From
* Flawed assumption that user cannot control the HTTP-Header
  * Inadequate validation
* Rises from insecure configuration rather than insecure coding

### Mitigations
* **Protect Absolute URLs**: Refer to the value in configuration file rather than the Host Header
* **Validate Host_Header**: eg. Using *ALLOWED_HOSTS* settings in Django
* **Don't Support Host Override headers**: *X-Forwarded-Host* header in particular
* **Whitelist permitted Domains**
* **Be careful with internal-only virtual hosts**

[Go to Table Of Contents](#table-of-contents)

## 2. Cross-Site Scripting (XSS)


[Go to Table Of Contents](#table-of-contents)

## 3. SQL Injection (SQLi)
* ` Value' OR 1=1; --` OR `VALUE; UPDATE XXX ; --`
* Prepared Statements
* 

[Go to Table Of Contents](#table-of-contents)

## 4. HTTP Request Smuggling (CL.TE and TE.CL)
HTTP request smuggling vulnerabilities arise in situations where the front-end server and back-end server use different mechanisms for determining the boundaries between requests. This may be due to discrepancies between whether HTTP/1 servers use the Content-Length header or chunked transfer encoding to determine where each request ends. In HTTP/2 environments, the common practice of downgrading HTTP/2 requests for the back-end is also fraught with issues and enables or simplifies a number of additional attacks. [[2]](https://portswigger.net/web-security/request-smuggling)


### TE.CL (Tranfer-Encoding; Content-Length)
### CL.TE (Content-Length; Transfer-Encoding)
### TE.TE (Obfuscating the TE Header)

### Mitigations
* Use HTTP/2 end to end and **disable HTTP downgrading**
* **Validate** the rewritten request against the HTTP/1.1 specification
* Make the **front-end server normalize ambiguous requests** and **make the back-end server reject any that are still ambiguous**, closing the TCP connection in the process


[Go to Table Of Contents](#table-of-contents)



## References
1. [https://portswigger.net/web-security/host-header](https://portswigger.net/web-security/host-header)
2. [https://portswigger.net/web-security/request-smuggling](https://portswigger.net/web-security/request-smuggling)
3. 